# JAVA知识

## 基础知识
- PC原理
    - 二进制、进制转换。
    - 八进制、十六进制是二进制的补充形式。表现形式为八进制为3位二进制 十六进制为四位二进制。
- **二进制**
    - **负数的二进制为其正数的值取反加1**
例：-7 的二进制为7的二进制值取反加1
- 计算机的组成单位
    - 位    (bit)
    - 字节  (byte)
    - 字    (word)

> 位（bit）是计算机最小的数据单位（0或者1）也是储存器中存储信息的最小单位。

> 字节（Byte）字节是计算机中表示存储容量的最常用的基本单位。一个字节由8位二进制组成，一个字符占一个字节，一个汉字占两个字节。

> 字（Word）是指在计算机中作为一个整体被储存存取、传送、处理的一组二进制数。一个字的位数（即字长）是计算机系统结构的一个重要特性，字长由CPU的类型所决定。

- **字和字长的区别：字是单位，字长是指标**

### Java数据类型和运算符
- 标识符要求
    - 数字、字母_及$组成
    - 不能以数字开头
    - 不能使用关键字
    - 遵循**见名知意**原则

- **类名首字母大写,方法名首字母小写**

- 基本数据类型

|关键字|字节数|位数|
|-|-|-|
|byte| 一个字节 |8位|
|short| 两个字节 |16位|
|int| 四个字节 |32位|
|long| 八个字节 |64位|
|double| 八个字节|64位|
|float| 四个字节|32位|


- <font color=red>**整数默认的数据类型为int ，小数默认的数据类型为double。(运算时同理)**
- 运算符
	- **右移（>>（有符号的））**如果是负数，前面补1，如果为正数补0</font>
	- 三目运算符如果表达式1和表达式2的类型不相同,那么需要对交集类型的自动参考转换
		+ 详见[这里](https://www.cnblogs.com/Yxxxxx/p/6858618.html)
### Java流程控制与数组 
- switch语句：
```java
switch（条件/数值）{
	case：
		break；
	case：
		break；
	default：
		break；
}
```
<font color=red>**必须有`break`**</font>

- do while语句：

``` java
do{
	//do while循环至少执行一次	
}while();
```


### <font color=red>break和countiue的区别</font>
**break:强行跳出整个循环（作用域内）**  
**countiue：忽略本次循环,下一轮循环继续**

- **递归**
	- 一个方法体内调用它自身
	- **产生的条件**
		- 必须有出口（向已知方向递归）
		- 必须有约束条件，且有调用自身的过程

- <font color=red> **重载**</font>:函数功能相同，但是参数个数和类型不同，和返回值无关。典型例子就是构造器的重载

- **方法的注意点**
	- 方法中不能定义方法
	- 方法必须定义在类中
	- 方法不能独立执行，必须使用类或者对象作为调用者
	- 方法中的参数传递机制：值传递

- 数组
	- 静态定义
	```java
	int[] arr={1,34,43,56,1}
	```

	- 动态定义 
	```java
	int[] arr =new int[3];
	```

	- 数组创建会开辟一块**堆内存**
	- 一个数组中只能储存**一种**类型的数据
	- 数组的长度一旦固定，不能修改
	- 数组查找 
		- （二分法）折半查找：前提是有序数组

- 二维数组
	- 定义  `int[ ][ ] a=new int [ ] [ ]`
	- 实质就是数组里面的元素还是数组。(数组中存放的是另一个数组的引用)


## 面向对象
- 类
	- 对于现实间事物有一定共同特征事物的抽象。
- 对象
	- 对于类的实例化，即一个具体的事物。
- 两者之间的关系
	- 类是对象的抽象，对象是类的实例化体现
- <font color=red>**局部变量和成员变量的对比**</font>
> 成员变量指的是在**类**中定义的变量，且成员变量**无需显式初始化**，系统会在类的准备阶段或创建该类的实例时进行默认初始化
> 局部变量指的是在方法中定义的变量  
> 局部变量存在于**栈**中，而成员变量存在于**堆**中。  
> **成员变量的生命周期随着对象的产生而产生，消亡而消亡**  
> 成员变量与局部变量同名时，在局部变量的作用域内局部变量优先**  


- <font color=red>**为什么有栈内存和堆内存之分**</font>
> 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法中定义的变量将会逐个放入这块栈内存，随着方法的执行结束，这个方法的内存栈讲自然销毁，因此，所有在方法中定义的局部变量都是放在栈内存中的，在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复运用（因为对象的创建成本通常较大）这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（在方法的参数传递时很常见），此对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收器才会在合适的时候收回。

### 面向对象的三大特征
- 继承、封装、多态
	- 继承
		+ 继承是面向对象最显著的特征,是从已有的类中派生出新的类,新的类会具有被派生类的数据属性和行为,并扩充新的属性和行为,并且可以使用父类的功能和属性,但是不能选择性的继承父类,一个子类只能直接继承一个父类,但是不能继承父类的私有方法和属性,Object类是所有类的父类,也就是最顶层的类,当子类中有与父类同名的属性时，要调用父类属性需要在前面加super
		+ 继承后构造函数的特点
			1. 当创建一个子类对象的时候，会先调用父类的构造方法，再调用子类的构造方法
			2.	每一个子类构造方法默认都会调用父类的空参构造方法
			3.	当父类没有空参构造的时候，子类就必须手动调用父类构造方法
			4.	super语句和this语句都要写在第一行
			5.	子类的每一个构造方法都必须直接或间接调用父类构造方法
	- 封装
		+ 封装是将逻辑过程和数据内容隐藏起来,保护起来,只提供一些开放的接口或方法供外界使用,适当的封装有利于程序的理解和维护,加强了程序的安全性
	- 多态
		+ 多态一般指程序在运行过程中存在不同的状态,多态扩展了java单继承带来的弊端
		+ 多态存在有三个前提:
			1. <font color=red>必须要有继承关系 </font>
			2. <font color=red>子类要重写父类的方法</font> 
			3. <font color=red>父类引用要指向子类对象</font>
		- 多态中的成员特点
		- 变量的值取决于引用（编译时类型），静态方法：取决于引用（编译时类型）
		- 一般方法：代码编译时看左边（看父类是否含有该方法，如果没有，编译不会通过）、运行时，看右边，执行的是子类方法的实体
		- 静态绑定：谁引用就是谁（变量和静态方法）
		- 动态绑定：谁调用就是谁（一般方法）
		
###**this和super**
- this
	- **this关键字总是指向调用该方法的对象**
	- 作用：
		1. 区分同名的成员变量和局部变量
		2. 区分当前对象的属性和其他对象的属性
		3. this引用可以用于构造器中作为默认引用
		4. `this（)`语句：实现构造方法之间的相互调用
		5. `this（)`语句只能放在构造方法的第一句
- super
	+ **super**一般指向当前对象的父类

> `this`和`super`都指的是对象,所以都不可以在static环境中使用
	
		

### 构造器（构造方法）
1. 目的只是用不同的方法来初始化（创建 ）对象,**构造器必须与类名相同**
2. 一旦提供了自定义构造器，系统将不会提供默认的构造器
3. 对于每个对象来说，构造器只在创建对象的时候都要执行一次。
4. 构造器不能被一般方法调用
5. <font color=red>构造器之间可以互相调用（但是需防止递归构造器的出现）</font>
6. <font color=red>构造器既不能定义返回值类型，也不能使用void声明构造器没有返回值</font>
7. 构造方法多用于传递参数    
	
<hr>

### 代码块
- 构造代码块
	- 在类中由`{ }`表示，作用是初始化所有对象共有的部分。在每一次创建对象都会调用。（调用早于构造方法）
- 静态代码块
	+ 在类中由`static{}`,在虚拟机加载类的时候就会加载执行,且只执行一次,所有对象共享一份
> 静态代码块在非静态代码块之前执行(静态代码块-->非静态代码块-->构造方法)  
> 静态代码块只在第一次new时执行一次,之后不再执行,而非静态代码块在每次new时都会执行,非静态代码块可在普通方法中	定义(意义不大),但是静态代码块不行

- 同步代码块
	+ 在方法内部使用`synchronizd(obj){}`,一般在需要达到线程安全的情况下使用,详见[这里](https://www.cnblogs.com/beiyetengqing/p/6213437.html)


- **匿名类对象特点：只能使用一次**

- static关键字
	- 实际上作用是用来区分成员变量、方法、内部类、初始化块这四种成员到底属于类本身还是属于实例（对象）
	- 可以修饰构造代码块、成员变量、成员方法
	- 当static修饰成员变量时，这个成员变量也叫类变量
    - <font color=red>static修饰的方法中不能使用this引用</font>
	- **可以修饰类，但类必须是内部类**
	
>  最好不要使用对象去调用static修饰的成员变量、方法！！！！！

- <font color=red>**静态成员和一般成员变量的区别**</font>
	1.	储存位置的不同，静态方法储存在**方法区**，静态变量储存在**静态区**，成员变量（方法）储存在**堆**中
	2.	**生命周期不同，静态变量（方法）随类的加载而加载，成员变量（方法）随对象产生而产生**
	3.	静态成员（方法）可以直接使用**类名.变量名**来直接调用。
	4.	静态成员方法**只能访问静态成员，不能访问非静态成员**
**原因：静态成员的加载（类加载就加载了）早于非静态成员，所以静态成员可以调用非静态成员。**
- **重写和重载之间的区别**
	- 重载发生于同一个类的多个同名方法之间，只关注同名方法的参数列表（父类和子类之间可能发生重载）
	- 重写除修饰符外要求完全相同，且重写只出现在子类和父类之间
	- 子类重写了方法的访问权限要大于等于父类方法
	
- **final关键字（可以修饰：变量、类、方法）**
	- final修饰类后,该类不能被继承
	- final修饰变量后,变量不可再次被修改(常量)
	- final修饰的方法不能被重写，但是可以产生重载



###单例设计模式
- 单例类：如果一个类始终都只能创建一个实例，则这个类被称为单例类
**懒汉式：在需要创建对象的时候才new
饿汉式：在刚开始时就new好对象，调用时直接返回该对象**
区别：
	1.	懒汉式只有第一次调用时才new 对象 饿汉式直接new一个对象
	2.	懒汉式省内存 饿汉式耗费内存
	3.	懒汉式有线程安全问题 饿汉式不存在此问题

###抽象（关键字 abstract）
- **抽象类：有抽象方法的一定是抽象类，但是抽象类中不一定有抽象方法**
- **父类如果是抽象类且含有抽象方法，子类必须重写抽象方法或者继续让该方法抽象**
- **抽象类不能创建对象（无法实例化）原因：如果创建对象后，抽象方法无法体现**
- **抽象方法要么被子类实现，要么子类继续为抽象类**


### 接口
- interface（定义接口），与类同级、implements（接口的实现）
接口是对外暴露的一种规则，目的是拓展功能，弥补java的单继承缺陷，接口之间可以多实现（继承）
- 接口成员的特点：
	- 接口成员变量都是常量，接口的方法都是抽象方法
- 类和接口的关系：
	1. 一个类实现了接口，那么称这个类是这个接口的实现者
	2. 一个类如果实现了部分接口，那么这个类必定是抽象类
	3. 一个类实现了接口方法，此方法必定是public修饰


> 接口不能创建对象，但是可以创建引用！！！！  
>例如：A是B的子类，且B是一个接口，则可以：  
>`B b=new A()；//多态在接口中的应用`

- **抽象类和接口的区别**
	1.  都没有方法体，都不能够被实例化，无法通过new关键字创建实例
	2.	都可以包含抽象方法，实现接口或继承抽象类都必须实现其中的抽象方法
	3.	抽象类是一个类，接口和类属于并列关系
	4.	抽象类可以有非抽象方法，接口只能有抽象方法
	5.	抽象类可以有任意的成员变量，接口只有常量
	6.	抽象类只有单继承，接口可以多实现，接口之间可以多继承
	7.	抽象类的方法、变量必须写abstract，接口可以省略
	8.	接口中的方法之前的访问修饰符只能是共有的（public）


- `instanceof`运算符
用于判断一个引用类型变量是否属于一个类，返回值类型为boolean类型。   
**注意：instanceof运算符前面操作数的编译时类型要么与后面的类相同，要么和后面的类具有继承关系，否则编译错误。**

### 内部类
- 属性和方法不足以描述类中的一些特征，就需要内部类来表示
- 内部类的访问规则
	- 在外部访问一个类的内部类的格式
外部类名称.内部类名称 变量=外部类对象.内部类对象
	- 外部类访问内部类通过内部类对象来访问
	- 内部类可以直接访问外部类的属性和方法（包括私有成员）
	原因是内部类持有一个外部类的引用`Outter.this`
	- 内部类一般私有
	- 非静态内部类不能拥有静态成员
	- 如果外部类需要访问非静态内部类的成员，必须显式的创建非静态内部类对象来调用访问其实例成员
	- 创建内部类对象时，非静态内部类必须使用外部类对象来调用构造器
- 静态内部类
	- 特点：静态内部类只能访问静态成员
> 当外部类成员基本都为静态时，才会选择使用静态内部类
如果使用static修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。（所有用static修饰的成员都是这样）
静态内部类中可以包含静态成员，也可以包含非静态成员
接口内部类只能是静态内部类（因为接口中定义的内部类默认使用public static修饰）
创建内部类对象时，静态内部类只需使用外部类即可调用构造器
- **匿名内部类**
	- 前提：匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口
	 >创建匿名内部类时会立即创建一个该类的实例，这个类定义立即消失，匿名内部类不能重复使用。
匿名内部类不能是抽象类。因为系统在创建匿名内部类时，会立即创建匿名内部类的对象，因此不允许将匿名内部类定义为抽象类。
匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。

### 异常
- 错误：error 
- 异常：Exception（除0、数组越界、类型转换）
- 异常出现后的两种处理方式：
捕获异常：
```
try{
	可能出现异常的语句；
}catch（Exception e）{
	异常处理代码；
}finally{
	用于保护的，必须执行的代码释放,占用内存的代码
}
```
**特殊：try里面有return语句时，return后方法不会被回收，会等finally语句执行后才会被回收。**

- 抛出异常
	- `throws`(异常的声明)-------用于一个方法头、抛出的是异常的类名
	- `throw`--------用于方法体内部、抛出的异常的是一个对象

> 接口的实现类中的异常不能选择抛异常


###String  字符串（引用数据类型）
> 字符串一经定义，无法改变内容。  
> String类无法被继承，原因：API中显示String类为final

- 两种定义方式：
	- `String s =”love”相当于String[ ]{‘l’’o’’v’’e’}`	
	- `String s1=new String(“asasas”)`
- **区别：s的定义只有一个对象，而s2的定义有两个对象（new String为一个对象，as为另一个）**
- String基本方法	
```java 
length() // 获取字符串长度
substring() // 获取字符串的一个子串：
indexOf() // 获取（字符/子串）在字符串中第一次出现的位置
startsWith() // 判断一个字符串是否以指定内容开始
endsWith() // 判断一个字符串是否以指定内容结束
isEmpty() // 判断一个字符串是否为空
toLowerCase() //大小写转换（转小写） toUpperCase()//转大写
toCharArray() //字符串转字符数组
基本数据类型转String：使用String的构造方法 new String（基本数据类型[]）
String.valueOf（） String转基本数据类型
//String.valueOf方法可以转任何类型，包括Object类
trim（）去除空格（只能去除前面和后面）
compareTo（）//按位比较，返回值为具体数值，0为相等
split（）// 切割
replace（） //替换
```
- **前提：不论对字符串做什么操作，源字符串不变，操作后生成一个新字符串**

#### 字符串的操作类
- **StringBuilder和StringBuffer的区别**
	1.	StringBuffer为1.0版本出现的，而StringBuilder为1.5版本出现
	2.	StringBuffer是线程同步的（意味着安全），效率低；StringBuilder线程不同步，效率高，执行速度快。
	3.	一般使用StringBuilder。（执行速度快）
- StringBuilder的常用方法
```java
append()//添加字串
charAt()//查找字符（返回某一位置的字符）
delete()//删除字串
insert() //插入字串
replace()//替换字符
reverse()//反转字符串
subSequence() //取出字符串的一部分
```
- **字符串的比较**：
	- 双等比较的是地址，equals比较的是内容
	- String类重写了toString方法，用于返回它自身而不是它的地址

- 工具类
`命令：javadoc –d  文件目录 文件名`
- 基本数据类型的封装类（以Int为例）
**基本数据类型封装类的父类都是Number类**
- 常用方法
`MAX_VALUE` 最大值
`MIN_VALUE`  最小值
`SIZE` 	返回该类型储存所占用的位数

**自动装箱: 将int类型的数据直接装箱为Integer**  
**自动拆箱：将Integer类型的对象直接拆箱为int（包装类中的intValue方法）**  

- 字符串转基本数据类型：包装类的构造方法new Integer（String s）
**Interger的特殊情况：如果定义Integer对象的数值范围在byte只内（小于127）。就不会有新对象的产生，会直接指向此对象**
```java
Integer i3=128;		
Integer i4=128;			
sop(i3==i4);				
返回 false			
```
```java
Integer i1=23;	
Integer i2=23;
sop(i1==i2);
返回true
```		
常用方法：
```java
parseInt（"101"，2）//将二进制的101转换为十进制
toBinaryString（10）//将10转换为二进制
toOctalString（10）//将10转换为八进制
toHexString （17）//将17转换为十六进制
```



### 访问权限
public protected default（默认） private  
可以修饰类的修饰符：public private（只能修饰内部类）


##<font color=red>集合框架（Collection）</font>
- 集合理解参考[这里](http://blog.csdn.net/speedme/article/details/22398395)
- 数组和集合的区别：
	1.	数组长度固定，集合长度可变
	2.	数组只能放置一种数据类型，集合可以放置不同的数据类型（任何类型）
- Collection分类
Collection属于 `java.util`包

#### Iterator（迭代器）的使用
<font color=red>迭代器可简单理解为一次性的</font>

`ArrayList a=new ArrayList( )；`
`Iterator it=a. iterator（）；`
**注意：当使用Iterator遍历集合时，不能同时使用集合本身对集合进行增删改操作，可以使用ListIterator中的方法来进行操作**
#### List
List为**有序**集合，所以可以根据索引来获取每一个元素。
**有序指的是：是不是和存入顺序一致。**
List特有方法：`asList（）`接收一个数组，生成一个固定长度的list
##### List的常用子类：
- ArrayList：底层数据结构为**数组结构**，线程不安全，执行效率高
- LinkedList：底层数据结构为**链表结构**，查询，修改比较慢，删除，添加比较快。
- Vector：线程安全但效率低

#### Set
特点：无序且不可重复，无序指的是与储存的顺序不一致。
##### Set的常用子类：
- HashSet：底层数据结构为**哈希表结构**，储存位置不固定。不注重顺序（顺序由系统生成的哈希值决定），只注重唯一性。
	- HashSet的比较过程：当向HashSet中存入一个元素时，HashSet会调用该对象的hashCode（）方法来得到该对象的hashCode值，及需要通过equals（）方法比较，返回值都为true时才认为相同。
- TreeSet：底层数据结构为二叉树，不仅注重唯一性，还注重顺序。使用时必须使用外部比较器
<font color=red>二叉树的特点：每一个根节点大于它左边的所有元素，小于它右面的所有元素。且不论TreeSet或者TreeMap内的对象必须实现Comparable接口，重写compareTo方法否则不能操作</font> 
                                                      
#### 比较器
Comparable（接口）是默认（内部）的比较器，其中方法为`compareTo(Object o)`
ComparaTor是外部自行创建的（自定义）比较器，其中方法为`compare(Object o1,Object o2)`使用时必须要传入一个新的比较器（ComparaTor）。
**Comparator的优先级大于Comparable**  
- ComparaTor接口的使用：
	1.创建一个类来实现Comparator接口，实现compare方法
	2.使用构造方法传入实现了ComparaTor的对象作为实参
#### Map
- Map<K,V>一个双列集合，key—键值，键值唯一且指向唯一（value），一个键值映射一个值，和Collection属于并列关系。

##### Map的子类：
- Hashtable：底层结构为哈希表结构，不可使用null来充当键和值，同步，效率低，出现于jdk1.0；使用HashSet值作为key的值，key的值只关注唯一性
- HashMap：底层结构为哈希表结构，可以使用null来充当键和值，不同步，效率高，出现于jdk1.2；使用TreeSet值作为key的值，key 的值不仅关注唯一性，还关注顺序
- TreeMap：底层结构为二叉树，键值必须是自然有序。

#### Collections 工具类
- 常用方法：
	`binarySearch`	二分法查找（可指定比较器）
	`max `		返回集合的最大值（可指定比较器）
	`min`		返回集合的最小值（可指定比较器）
	`reverseOrder`	返回一个比较器，强行逆转一个比较器。
	`sort`		排序（可指定比较器）

#### Arrays工具类
- 常用方法：
	- `Arrays. binarySearch（）`二分法查找
	- `Arrays.sort( )`升序排序
	- `Arrays.toString( )`返回指定内容的字符串表示
- **可变参数：为了简化书写而出现(jdk1.5) 注意：可变参数必须写在最后一个**  


### 泛型（jdk1.5版本后出现）
- **意义：为了限制集合中储存的类型。泛型可以将运行时的错误提前到了编译阶段，提高了安全性，避免了强制类型转换。**  
- 向下限定：`<? extends E>` ?—通配符 
- 向上限定：`<? super E>`


## 线程
- 定义：所有运行中的任务通常对应一个进程，当一个程序进入内存运行时，即变为一个进程。进程是处于运行过程中的程序，并且具有一定的独立性。一个进程至少有一个线程，也可以有多个线程 。

- **什么时候使用Runnable或Thread？**	
	- 取决于这个类需不需要重写run之外的方法。
	- Runnable不影响本类的继承关系，以及类组成

- 特征：
	- 独立性：进程可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。没有经过进程本身允许的情况下，一个用户进程不能直接访问其他进程的地址空间。
	- 动态性：进程和程序的区别在于程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程中加入了时间的概念。进程具有自己的生命周期和状态。
	- 并发性：多个进程可以在单个处理器上并发执行，不会互相影响。  

- 线程的创建：
	1. 通过继承Thread类来创建并启动线程的步骤：
 		+ 定义Thread类的子类，重写该类的`run()`方法（线程执行体）
 		+ 创建Thread子类的实例（创建子线程)
 		+ 调用线程对象的`start（）`方法来启动线程。
	2. 通过实现Runnable接口来创建并启动线程的步骤：
		+  定义Runnable接口的实现类，重写该接口的`run（）`方法
		+ 创建Runnable实现类的实例
		+ 调用线程对象的`start（）`方法来启动线程
	3. 通过创建匿名内部类来创建和启动线程


- 线程的停止
`interrupt` ：唤醒一个被`sleep`或者被`wait`的线程（原理是改变循环条件）

- 线程的五种状态：
	- 新建 就绪 运行 阻塞 死亡
	- <font color=red>注意：
线程从阻塞状态只能进入就绪状态，不可直接进入运行状态
线程进入死亡状态后不可再次调用`start（）`方法</font>

- 后台线程（守护线程，精灵线程）：`setDaemon（boolean）`设置线程为守护线程
**该方法必须在启动之前调用**
<font color=red>如果所有的前台线程都死亡，则后台线程会自动死亡。如垃圾回收线程。</font>


##**多线程**

**多线程出现安全问题的前提：**

- 对于多个线程来说，必须同时操作共享资源
- 操作资源的代码有多条语句，如果出现挂起，未完整执行语句，由于数据未完成，导致数据发生异常

解决办法：`synchronized`(上锁)
每一把锁都是**唯一**的，所以指定一个唯一的对象，虽然允许使用任何对象作为同步监视器（锁），但是锁存在的意义是阻止两个线程对同一个共享资源进行并发访问，所以通常建议**使用可能被并发访问的共享资源充当锁同步监视器（锁）。**

1. 同步代码块（互斥区）（对象为监视器（锁））
```java
synchrinized（对象）{
		执行代码1；
		执行代码2；
}
```
<font color=red>**只要操作了共享数据就应该使用同步代码块**</font>

2. 同步方法（方法）
```java
public synchronized void test{
}
```
<font color=red>同步方法的锁对象就是当前类的对象（this）</font>

3. 同步静态方法
`public static synchronized void test{  }`
<font color=red>同步方法的同步监视器是`this` 即调用该方法的对象 。
静态同步方法的同步监视器（锁对象）是当前类.class</font>

- **wait和sleep的区别**
	1. wait会放弃执行资格，会释放锁。不占用cpu
	2. sleep放弃执行资格，但是不会释放锁，sleep后进入了阻塞状态，占用cpu

### 线程池：
- `wait()`---让线程冻结
- `notify()`---唤醒第一个冻结线程
- `notifyAll()`---唤醒所有冻结线程
- **使用前提是有锁，因为与锁有关，且锁可以是任意对象，所以将这三个方法定义在Object中。**
- <font color=red>
线程间通信时产生的线程安全问题解决办法：
	1. 只要是操作了共享的数据，都需要使用同步代码块，且同步代码块的锁必须统一</font>
	 <font color=red>
	2. 先判断是否继续循环，使用while来控制线程被唤醒后，必须判断是否执行，notifyAll全部唤醒线程，防止进程唤醒本类线程，导致安全问题。</font>



### 生产者、消费者模式
jdk1.5之前使用`while notifyAll`方法，之后使用`lock Condition`方法实现，相比较，` `方式更加灵活，可以指定需要启动的线程。

###  死锁
- 死锁出现的必要条件：
	1.	资源匮乏
	2.	有多个锁，多个线程都操作了此资源
	3.	锁之间有使用对方资源的情况，必须有两把锁以上，且需锁中有锁。


## IO流
- 分类
	- 根据流的操作数据的方式来分为字节流和字符流
	- 根据流向可分为输入流和输出流


- 字节流和字符流：
	- `OutputStream/ InputStream`是所有字节输出/输入流的父类
	- `Writer/Reader `是所有字符输出/输入流的父类

> <font color=red>流必须关闭！关闭后不可再次写入，不能重复关闭！输入和输出流不是同一个流！
关闭流后不可再次刷新流缓冲或者写入流读取流</font>

- 字节流 `Writer/Reader`
- IO的异常处理
一般在`finally（）`方法中调用`close（）`方法，需注意：流必须在try外部定义，因为需要关流
- 字符流的缓冲区（前缀带Buffered）
Buffered不能单独使用，需要传入一个流

### 装饰设计模式
- 目的是为了增强某些类的功能，创建一个新类，然后一般在构造方法中将被装饰者作为参数，这个自定义类就是装饰类，这两个类的功能是相似的，但是会对功能做一个增强，装饰类和被装饰类也是一个体系中的类。

- 装饰和继承的关系
相对于继承来说，降低了类之间的耦合性，且装饰类和被装饰类属于同一体系。

- 字节流
OutputStream/InputStream 
**写入时需注意只能写入Byte类型的值，所以需要String的`getBytes()`方法**
- 读取的方法：
	- 一个字节一个字节的读取
	- 读入一个数组
	- 将内容一次性读出


- 键盘录入：
InputStream i=System.in;


- **转换流**
InputStreamReader/OutoutStreamReader  
`InputStreamReader isr=new InputStremReader(new FileInputStream(“目录”))`

- 如何选择流：
	1.	确定源和目的，源是数据的来源，目的是数据走到哪
	2.	确定操作对象是否为纯文本文件

## 网络编程
- 三要素：ip、端口、协议
- OSI网络层次参考模型/TCP&IP参考模型
- **TCP和UDP的区别**
	1.	基于连接和无连接
	2.	TCP要求系统资源较多，UPD较少
	3.	UDP程序结构较简单
	4.	流模式（TCP）和数据包模式（UDP）
	5.	TCP保证数据正确性和数据的顺序，UDP不保证
	6.	其他请[参考](http://blog.csdn.net/li_ning_/article/details/52117463)

###socket----插座  套接字
- socket就是为了网络服务提供的一种机制
通信的两端都是socket
socket位于传输层和会话层之间
网络的通信其实都是socket间的通信
数据在两个socket间进行IO传输
java中对应Socket类


- **java实现TCP和UDP连接的步骤**


- TCP：
	1.	创建客户端和服务端
	2.	服务端：建立服务端的SeverSocket，监听端口；获取连接的客户端对象（使用accept方法，此方法为阻塞式方法，会一直持续监听）；定义socket对象的输入输出流；使用输出流发送给客户端信息，使用输入流获取客户端发送的信息。
	- 客户端：建立客户端的Socket，指定连接的服务端地址和端口；定义socket对象的输入输出流；使用输出流（字节流）向服务端发送信息，使用输入流（字节流）获取服务器的回执。

- UDP：
	1.	创建接收端和发送端
	2.	发送端：建立DatagremScoket对象，指定本方端口及ip；使用转换流获取输入要发送的内容，并且转换为字节；将内容打包，然后发送；
	- 接受端：建立DatagremScoket对象，监听端口，将接受到的数据包拆包（使用receive方法，此方法为阻塞式方法，）为字节数组。




