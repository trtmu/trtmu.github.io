<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Madman's"><title> | Trtmu</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Trtmu</h1><a id="logo" href="/.">Trtmu</a><p class="description">2018/09/17</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">Sep 17, 2018<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="JAVA知识"><a href="#JAVA知识" class="headerlink" title="JAVA知识"></a>JAVA知识</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>PC原理<ul>
<li>二进制、进制转换。</li>
<li>八进制、十六进制是二进制的补充形式。表现形式为八进制为3位二进制 十六进制为四位二进制。</li>
</ul>
</li>
<li><strong>二进制</strong><ul>
<li><strong>负数的二进制为其正数的值取反加1</strong><br>例：-7 的二进制为7的二进制值取反加1</li>
</ul>
</li>
<li>计算机的组成单位<ul>
<li>位    (bit)</li>
<li>字节  (byte)</li>
<li>字    (word)</li>
</ul>
</li>
</ul>
<blockquote>
<p>位（bit）是计算机最小的数据单位（0或者1）也是储存器中存储信息的最小单位。</p>
</blockquote>
<blockquote>
<p>字节（Byte）字节是计算机中表示存储容量的最常用的基本单位。一个字节由8位二进制组成，一个字符占一个字节，一个汉字占两个字节。</p>
</blockquote>
<blockquote>
<p>字（Word）是指在计算机中作为一个整体被储存存取、传送、处理的一组二进制数。一个字的位数（即字长）是计算机系统结构的一个重要特性，字长由CPU的类型所决定。</p>
</blockquote>
<ul>
<li><strong>字和字长的区别：字是单位，字长是指标</strong></li>
</ul>
<h3 id="Java数据类型和运算符"><a href="#Java数据类型和运算符" class="headerlink" title="Java数据类型和运算符"></a>Java数据类型和运算符</h3><ul>
<li><p>标识符要求</p>
<ul>
<li>数字、字母_及$组成</li>
<li>不能以数字开头</li>
<li>不能使用关键字</li>
<li>遵循<strong>见名知意</strong>原则</li>
</ul>
</li>
<li><p><strong>类名首字母大写,方法名首字母小写</strong></p>
</li>
<li><p>基本数据类型</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>字节数</th>
<th>位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>一个字节</td>
<td>8位</td>
</tr>
<tr>
<td>short</td>
<td>两个字节</td>
<td>16位</td>
</tr>
<tr>
<td>int</td>
<td>四个字节</td>
<td>32位</td>
</tr>
<tr>
<td>long</td>
<td>八个字节</td>
<td>64位</td>
</tr>
<tr>
<td>double</td>
<td>八个字节</td>
<td>64位</td>
</tr>
<tr>
<td>float</td>
<td>四个字节</td>
<td>32位</td>
</tr>
</tbody>
</table>
<ul>
<li><font color="red"><strong>整数默认的数据类型为int ，小数默认的数据类型为double。(运算时同理)</strong></font></li>
<li>运算符<ul>
<li><strong>右移（&gt;&gt;（有符号的））</strong>如果是负数，前面补1，如果为正数补0</li>
<li>三目运算符如果表达式1和表达式2的类型不相同,那么需要对交集类型的自动参考转换<ul>
<li>详见<a href="https://www.cnblogs.com/Yxxxxx/p/6858618.html" target="_blank" rel="noopener">这里</a><h3 id="Java流程控制与数组"><a href="#Java流程控制与数组" class="headerlink" title="Java流程控制与数组"></a>Java流程控制与数组</h3></li>
</ul>
</li>
</ul>
</li>
<li>switch语句：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>（条件/数值）&#123;</span><br><span class="line">	<span class="keyword">case</span>：</span><br><span class="line">		<span class="keyword">break</span>；</span><br><span class="line">	<span class="keyword">case</span>：</span><br><span class="line">		<span class="keyword">break</span>；</span><br><span class="line">	<span class="keyword">default</span>：</span><br><span class="line">		<span class="keyword">break</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<font color="red"><strong>必须有<code>break</code></strong></font>

<ul>
<li>do while语句：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//do while循环至少执行一次	</span></span><br><span class="line">&#125;<span class="keyword">while</span>();</span><br></pre></td></tr></table></figure>
<h3 id="break和countiue的区别"><a href="#break和countiue的区别" class="headerlink" title="break和countiue的区别"></a><font color="red">break和countiue的区别</font></h3><p><strong>break:强行跳出整个循环（作用域内）</strong><br><strong>countiue：忽略本次循环,下一轮循环继续</strong></p>
<ul>
<li><p><strong>递归</strong></p>
<ul>
<li>一个方法体内调用它自身</li>
<li><strong>产生的条件</strong><ul>
<li>必须有出口（向已知方向递归）</li>
<li>必须有约束条件，且有调用自身的过程</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red"> <strong>重载</strong></font>:函数功能相同，但是参数个数和类型不同，和返回值无关。典型例子就是构造器的重载</p>
</li>
<li><p><strong>方法的注意点</strong></p>
<ul>
<li>方法中不能定义方法</li>
<li>方法必须定义在类中</li>
<li>方法不能独立执行，必须使用类或者对象作为调用者</li>
<li>方法中的参数传递机制：值传递</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li><p>静态定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">34</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态定义 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组创建会开辟一块<strong>堆内存</strong></p>
</li>
<li>一个数组中只能储存<strong>一种</strong>类型的数据</li>
<li>数组的长度一旦固定，不能修改</li>
<li>数组查找 <ul>
<li>（二分法）折半查找：前提是有序数组</li>
</ul>
</li>
</ul>
</li>
<li><p>二维数组</p>
<ul>
<li>定义  <code>int[ ][ ] a=new int [ ] [ ]</code></li>
<li>实质就是数组里面的元素还是数组。(数组中存放的是另一个数组的引用)</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>类<ul>
<li>对于现实间事物有一定共同特征事物的抽象。</li>
</ul>
</li>
<li>对象<ul>
<li>对于类的实例化，即一个具体的事物。</li>
</ul>
</li>
<li>两者之间的关系<ul>
<li>类是对象的抽象，对象是类的实例化体现</li>
</ul>
</li>
<li><font color="red"><strong>局部变量和成员变量的对比</strong></font><blockquote>
<p>成员变量指的是在<strong>类</strong>中定义的变量，且成员变量<strong>无需显式初始化</strong>，系统会在类的准备阶段或创建该类的实例时进行默认初始化<br>局部变量指的是在方法中定义的变量<br>局部变量存在于<strong>栈</strong>中，而成员变量存在于<strong>堆</strong>中。<br><strong>成员变量的生命周期随着对象的产生而产生，消亡而消亡</strong><br>成员变量与局部变量同名时，在局部变量的作用域内局部变量优先**  </p>
</blockquote>
</li>
</ul>
<ul>
<li><font color="red"><strong>为什么有栈内存和堆内存之分</strong></font><blockquote>
<p>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法中定义的变量将会逐个放入这块栈内存，随着方法的执行结束，这个方法的内存栈讲自然销毁，因此，所有在方法中定义的局部变量都是放在栈内存中的，在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复运用（因为对象的创建成本通常较大）这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（在方法的参数传递时很常见），此对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收器才会在合适的时候收回。</p>
</blockquote>
</li>
</ul>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><ul>
<li>继承、封装、多态<ul>
<li>继承<ul>
<li>继承是面向对象最显著的特征,是从已有的类中派生出新的类,新的类会具有被派生类的数据属性和行为,并扩充新的属性和行为,并且可以使用父类的功能和属性,但是不能选择性的继承父类,一个子类只能直接继承一个父类,但是不能继承父类的私有方法和属性,Object类是所有类的父类,也就是最顶层的类,当子类中有与父类同名的属性时，要调用父类属性需要在前面加super</li>
<li>继承后构造函数的特点<ol>
<li>当创建一个子类对象的时候，会先调用父类的构造方法，再调用子类的构造方法</li>
<li>每一个子类构造方法默认都会调用父类的空参构造方法</li>
<li>当父类没有空参构造的时候，子类就必须手动调用父类构造方法</li>
<li>super语句和this语句都要写在第一行</li>
<li>子类的每一个构造方法都必须直接或间接调用父类构造方法</li>
</ol>
</li>
</ul>
</li>
<li>封装<ul>
<li>封装是将逻辑过程和数据内容隐藏起来,保护起来,只提供一些开放的接口或方法供外界使用,适当的封装有利于程序的理解和维护,加强了程序的安全性</li>
</ul>
</li>
<li>多态<ul>
<li>多态一般指程序在运行过程中存在不同的状态,多态扩展了java单继承带来的弊端</li>
<li>多态存在有三个前提:<ol>
<li><font color="red">必须要有继承关系 </font></li>
<li><font color="red">子类要重写父类的方法</font> </li>
<li><font color="red">父类引用要指向子类对象</font></li>
</ol>
</li>
</ul>
<ul>
<li>多态中的成员特点</li>
<li>变量的值取决于引用（编译时类型），静态方法：取决于引用（编译时类型）</li>
<li>一般方法：代码编译时看左边（看父类是否含有该方法，如果没有，编译不会通过）、运行时，看右边，执行的是子类方法的实体</li>
<li>静态绑定：谁引用就是谁（变量和静态方法）</li>
<li>动态绑定：谁调用就是谁（一般方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>###<strong>this和super</strong></p>
<ul>
<li>this<ul>
<li><strong>this关键字总是指向调用该方法的对象</strong></li>
<li>作用：<ol>
<li>区分同名的成员变量和局部变量</li>
<li>区分当前对象的属性和其他对象的属性</li>
<li>this引用可以用于构造器中作为默认引用</li>
<li><code>this（)</code>语句：实现构造方法之间的相互调用</li>
<li><code>this（)</code>语句只能放在构造方法的第一句</li>
</ol>
</li>
</ul>
</li>
<li>super<ul>
<li><strong>super</strong>一般指向当前对象的父类</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>this</code>和<code>super</code>都指的是对象,所以都不可以在static环境中使用</p>
</blockquote>
<h3 id="构造器（构造方法）"><a href="#构造器（构造方法）" class="headerlink" title="构造器（构造方法）"></a>构造器（构造方法）</h3><ol>
<li>目的只是用不同的方法来初始化（创建 ）对象,<strong>构造器必须与类名相同</strong></li>
<li>一旦提供了自定义构造器，系统将不会提供默认的构造器</li>
<li>对于每个对象来说，构造器只在创建对象的时候都要执行一次。</li>
<li>构造器不能被一般方法调用</li>
<li><font color="red">构造器之间可以互相调用（但是需防止递归构造器的出现）</font></li>
<li><font color="red">构造器既不能定义返回值类型，也不能使用void声明构造器没有返回值</font></li>
<li>构造方法多用于传递参数    </li>
</ol>
<hr>

<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul>
<li>构造代码块<ul>
<li>在类中由<code>{ }</code>表示，作用是初始化所有对象共有的部分。在每一次创建对象都会调用。（调用早于构造方法）</li>
</ul>
</li>
<li><p>静态代码块</p>
<ul>
<li>在类中由<code>static{}</code>,在虚拟机加载类的时候就会加载执行,且只执行一次,所有对象共享一份<blockquote>
<p>静态代码块在非静态代码块之前执行(静态代码块–&gt;非静态代码块–&gt;构造方法)<br>静态代码块只在第一次new时执行一次,之后不再执行,而非静态代码块在每次new时都会执行,非静态代码块可在普通方法中    定义(意义不大),但是静态代码块不行</p>
</blockquote>
</li>
</ul>
</li>
<li><p>同步代码块</p>
<ul>
<li>在方法内部使用<code>synchronizd(obj){}</code>,一般在需要达到线程安全的情况下使用,详见<a href="https://www.cnblogs.com/beiyetengqing/p/6213437.html" target="_blank" rel="noopener">这里</a></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>匿名类对象特点：只能使用一次</strong></p>
</li>
<li><p>static关键字</p>
<ul>
<li>实际上作用是用来区分成员变量、方法、内部类、初始化块这四种成员到底属于类本身还是属于实例（对象）</li>
<li>可以修饰构造代码块、成员变量、成员方法</li>
<li>当static修饰成员变量时，这个成员变量也叫类变量</li>
<li><font color="red">static修饰的方法中不能使用this引用</font></li>
<li><strong>可以修饰类，但类必须是内部类</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p> 最好不要使用对象去调用static修饰的成员变量、方法！！！！！</p>
</blockquote>
<ul>
<li><font color="red"><strong>静态成员和一般成员变量的区别</strong></font><ol>
<li>储存位置的不同，静态方法储存在<strong>方法区</strong>，静态变量储存在<strong>静态区</strong>，成员变量（方法）储存在<strong>堆</strong>中</li>
<li><strong>生命周期不同，静态变量（方法）随类的加载而加载，成员变量（方法）随对象产生而产生</strong></li>
<li>静态成员（方法）可以直接使用<strong>类名.变量名</strong>来直接调用。</li>
<li>静态成员方法<strong>只能访问静态成员，不能访问非静态成员</strong><br><strong>原因：静态成员的加载（类加载就加载了）早于非静态成员，所以静态成员可以调用非静态成员。</strong></li>
</ol>
</li>
<li><p><strong>重写和重载之间的区别</strong></p>
<ul>
<li>重载发生于同一个类的多个同名方法之间，只关注同名方法的参数列表（父类和子类之间可能发生重载）</li>
<li>重写除修饰符外要求完全相同，且重写只出现在子类和父类之间</li>
<li>子类重写了方法的访问权限要大于等于父类方法</li>
</ul>
</li>
<li><p><strong>final关键字（可以修饰：变量、类、方法）</strong></p>
<ul>
<li>final修饰类后,该类不能被继承</li>
<li>final修饰变量后,变量不可再次被修改(常量)</li>
<li>final修饰的方法不能被重写，但是可以产生重载</li>
</ul>
</li>
</ul>
<p>###单例设计模式</p>
<ul>
<li>单例类：如果一个类始终都只能创建一个实例，则这个类被称为单例类<br><strong>懒汉式：在需要创建对象的时候才new<br>饿汉式：在刚开始时就new好对象，调用时直接返回该对象</strong><br>区别：<ol>
<li>懒汉式只有第一次调用时才new 对象 饿汉式直接new一个对象</li>
<li>懒汉式省内存 饿汉式耗费内存</li>
<li>懒汉式有线程安全问题 饿汉式不存在此问题</li>
</ol>
</li>
</ul>
<p>###抽象（关键字 abstract）</p>
<ul>
<li><strong>抽象类：有抽象方法的一定是抽象类，但是抽象类中不一定有抽象方法</strong></li>
<li><strong>父类如果是抽象类且含有抽象方法，子类必须重写抽象方法或者继续让该方法抽象</strong></li>
<li><strong>抽象类不能创建对象（无法实例化）原因：如果创建对象后，抽象方法无法体现</strong></li>
<li><strong>抽象方法要么被子类实现，要么子类继续为抽象类</strong></li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>interface（定义接口），与类同级、implements（接口的实现）<br>接口是对外暴露的一种规则，目的是拓展功能，弥补java的单继承缺陷，接口之间可以多实现（继承）</li>
<li>接口成员的特点：<ul>
<li>接口成员变量都是常量，接口的方法都是抽象方法</li>
</ul>
</li>
<li>类和接口的关系：<ol>
<li>一个类实现了接口，那么称这个类是这个接口的实现者</li>
<li>一个类如果实现了部分接口，那么这个类必定是抽象类</li>
<li>一个类实现了接口方法，此方法必定是public修饰</li>
</ol>
</li>
</ul>
<blockquote>
<p>接口不能创建对象，但是可以创建引用！！！！<br>例如：A是B的子类，且B是一个接口，则可以：<br><code>B b=new A()；//多态在接口中的应用</code></p>
</blockquote>
<ul>
<li><strong>抽象类和接口的区别</strong><ol>
<li>都没有方法体，都不能够被实例化，无法通过new关键字创建实例</li>
<li>都可以包含抽象方法，实现接口或继承抽象类都必须实现其中的抽象方法</li>
<li>抽象类是一个类，接口和类属于并列关系</li>
<li>抽象类可以有非抽象方法，接口只能有抽象方法</li>
<li>抽象类可以有任意的成员变量，接口只有常量</li>
<li>抽象类只有单继承，接口可以多实现，接口之间可以多继承</li>
<li>抽象类的方法、变量必须写abstract，接口可以省略</li>
<li>接口中的方法之前的访问修饰符只能是共有的（public）</li>
</ol>
</li>
</ul>
<ul>
<li><code>instanceof</code>运算符<br>用于判断一个引用类型变量是否属于一个类，返回值类型为boolean类型。<br><strong>注意：instanceof运算符前面操作数的编译时类型要么与后面的类相同，要么和后面的类具有继承关系，否则编译错误。</strong></li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul>
<li>属性和方法不足以描述类中的一些特征，就需要内部类来表示</li>
<li>内部类的访问规则<ul>
<li>在外部访问一个类的内部类的格式<br>外部类名称.内部类名称 变量=外部类对象.内部类对象</li>
<li>外部类访问内部类通过内部类对象来访问</li>
<li>内部类可以直接访问外部类的属性和方法（包括私有成员）<br>原因是内部类持有一个外部类的引用<code>Outter.this</code></li>
<li>内部类一般私有</li>
<li>非静态内部类不能拥有静态成员</li>
<li>如果外部类需要访问非静态内部类的成员，必须显式的创建非静态内部类对象来调用访问其实例成员</li>
<li>创建内部类对象时，非静态内部类必须使用外部类对象来调用构造器</li>
</ul>
</li>
<li>静态内部类<ul>
<li>特点：静态内部类只能访问静态成员<blockquote>
<p>当外部类成员基本都为静态时，才会选择使用静态内部类<br>如果使用static修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。（所有用static修饰的成员都是这样）<br>静态内部类中可以包含静态成员，也可以包含非静态成员<br>接口内部类只能是静态内部类（因为接口中定义的内部类默认使用public static修饰）<br>创建内部类对象时，静态内部类只需使用外部类即可调用构造器</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>匿名内部类</strong><ul>
<li>前提：匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口<blockquote>
<p>创建匿名内部类时会立即创建一个该类的实例，这个类定义立即消失，匿名内部类不能重复使用。<br>匿名内部类不能是抽象类。因为系统在创建匿名内部类时，会立即创建匿名内部类的对象，因此不允许将匿名内部类定义为抽象类。<br>匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>错误：error </li>
<li>异常：Exception（除0、数组越界、类型转换）</li>
<li>异常出现后的两种处理方式：<br>捕获异常：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	可能出现异常的语句；</span><br><span class="line">&#125;catch（Exception e）&#123;</span><br><span class="line">	异常处理代码；</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	用于保护的，必须执行的代码释放,占用内存的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>特殊：try里面有return语句时，return后方法不会被回收，会等finally语句执行后才会被回收。</strong></p>
<ul>
<li>抛出异常<ul>
<li><code>throws</code>(异常的声明)——-用于一个方法头、抛出的是异常的类名</li>
<li><code>throw</code>——–用于方法体内部、抛出的异常的是一个对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>接口的实现类中的异常不能选择抛异常</p>
</blockquote>
<p>###String  字符串（引用数据类型）</p>
<blockquote>
<p>字符串一经定义，无法改变内容。<br>String类无法被继承，原因：API中显示String类为final</p>
</blockquote>
<ul>
<li>两种定义方式：<ul>
<li><code>String s =”love”相当于String[ ]{‘l’’o’’v’’e’}</code>    </li>
<li><code>String s1=new String(“asasas”)</code></li>
</ul>
</li>
<li><strong>区别：s的定义只有一个对象，而s2的定义有两个对象（new String为一个对象，as为另一个）</strong></li>
<li><p>String基本方法    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">length() <span class="comment">// 获取字符串长度</span></span><br><span class="line">substring() <span class="comment">// 获取字符串的一个子串：</span></span><br><span class="line">indexOf() <span class="comment">// 获取（字符/子串）在字符串中第一次出现的位置</span></span><br><span class="line">startsWith() <span class="comment">// 判断一个字符串是否以指定内容开始</span></span><br><span class="line">endsWith() <span class="comment">// 判断一个字符串是否以指定内容结束</span></span><br><span class="line">isEmpty() <span class="comment">// 判断一个字符串是否为空</span></span><br><span class="line">toLowerCase() <span class="comment">//大小写转换（转小写） toUpperCase()//转大写</span></span><br><span class="line">toCharArray() <span class="comment">//字符串转字符数组</span></span><br><span class="line">基本数据类型转String：使用String的构造方法 <span class="keyword">new</span> String（基本数据类型[]）</span><br><span class="line">String.valueOf（） String转基本数据类型</span><br><span class="line"><span class="comment">//String.valueOf方法可以转任何类型，包括Object类</span></span><br><span class="line">trim（）去除空格（只能去除前面和后面）</span><br><span class="line">compareTo（）<span class="comment">//按位比较，返回值为具体数值，0为相等</span></span><br><span class="line">split（）<span class="comment">// 切割</span></span><br><span class="line">replace（） <span class="comment">//替换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>前提：不论对字符串做什么操作，源字符串不变，操作后生成一个新字符串</strong></p>
</li>
</ul>
<h4 id="字符串的操作类"><a href="#字符串的操作类" class="headerlink" title="字符串的操作类"></a>字符串的操作类</h4><ul>
<li><strong>StringBuilder和StringBuffer的区别</strong><ol>
<li>StringBuffer为1.0版本出现的，而StringBuilder为1.5版本出现</li>
<li>StringBuffer是线程同步的（意味着安全），效率低；StringBuilder线程不同步，效率高，执行速度快。</li>
<li>一般使用StringBuilder。（执行速度快）</li>
</ol>
</li>
<li><p>StringBuilder的常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">append()<span class="comment">//添加字串</span></span><br><span class="line">charAt()<span class="comment">//查找字符（返回某一位置的字符）</span></span><br><span class="line">delete()<span class="comment">//删除字串</span></span><br><span class="line">insert() <span class="comment">//插入字串</span></span><br><span class="line">replace()<span class="comment">//替换字符</span></span><br><span class="line">reverse()<span class="comment">//反转字符串</span></span><br><span class="line">subSequence() <span class="comment">//取出字符串的一部分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串的比较</strong>：</p>
<ul>
<li>双等比较的是地址，equals比较的是内容</li>
<li>String类重写了toString方法，用于返回它自身而不是它的地址</li>
</ul>
</li>
<li><p>工具类<br><code>命令：javadoc –d  文件目录 文件名</code></p>
</li>
<li>基本数据类型的封装类（以Int为例）<br><strong>基本数据类型封装类的父类都是Number类</strong></li>
<li>常用方法<br><code>MAX_VALUE</code> 最大值<br><code>MIN_VALUE</code>  最小值<br><code>SIZE</code>     返回该类型储存所占用的位数</li>
</ul>
<p><strong>自动装箱: 将int类型的数据直接装箱为Integer</strong><br><strong>自动拆箱：将Integer类型的对象直接拆箱为int（包装类中的intValue方法）</strong>  </p>
<ul>
<li>字符串转基本数据类型：包装类的构造方法new Integer（String s）<br><strong>Interger的特殊情况：如果定义Integer对象的数值范围在byte只内（小于127）。就不会有新对象的产生，会直接指向此对象</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i3=<span class="number">128</span>;		</span><br><span class="line">Integer i4=<span class="number">128</span>;			</span><br><span class="line">sop(i3==i4);				</span><br><span class="line">返回 <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1=<span class="number">23</span>;	</span><br><span class="line">Integer i2=<span class="number">23</span>;</span><br><span class="line">sop(i1==i2);</span><br><span class="line">返回<span class="keyword">true</span></span><br><span class="line">```		</span><br><span class="line">常用方法：</span><br><span class="line">```java</span><br><span class="line">parseInt（<span class="string">"101"</span>，<span class="number">2</span>）<span class="comment">//将二进制的101转换为十进制</span></span><br><span class="line">toBinaryString（<span class="number">10</span>）<span class="comment">//将10转换为二进制</span></span><br><span class="line">toOctalString（<span class="number">10</span>）<span class="comment">//将10转换为八进制</span></span><br><span class="line">toHexString （<span class="number">17</span>）<span class="comment">//将17转换为十六进制</span></span><br></pre></td></tr></table></figure>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>public protected default（默认） private<br>可以修饰类的修饰符：public private（只能修饰内部类）</p>
<p>##<font color="red">集合框架（Collection）</font></p>
<ul>
<li>集合理解参考<a href="http://blog.csdn.net/speedme/article/details/22398395" target="_blank" rel="noopener">这里</a></li>
<li>数组和集合的区别：<ol>
<li>数组长度固定，集合长度可变</li>
<li>数组只能放置一种数据类型，集合可以放置不同的数据类型（任何类型）</li>
</ol>
</li>
<li>Collection分类<br>Collection属于 <code>java.util</code>包</li>
</ul>
<h4 id="Iterator（迭代器）的使用"><a href="#Iterator（迭代器）的使用" class="headerlink" title="Iterator（迭代器）的使用"></a>Iterator（迭代器）的使用</h4><font color="red">迭代器可简单理解为一次性的</font>

<p><code>ArrayList a=new ArrayList( )；</code><br><code>Iterator it=a. iterator（）；</code><br><strong>注意：当使用Iterator遍历集合时，不能同时使用集合本身对集合进行增删改操作，可以使用ListIterator中的方法来进行操作</strong></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List为<strong>有序</strong>集合，所以可以根据索引来获取每一个元素。<br><strong>有序指的是：是不是和存入顺序一致。</strong><br>List特有方法：<code>asList（）</code>接收一个数组，生成一个固定长度的list</p>
<h5 id="List的常用子类："><a href="#List的常用子类：" class="headerlink" title="List的常用子类："></a>List的常用子类：</h5><ul>
<li>ArrayList：底层数据结构为<strong>数组结构</strong>，线程不安全，执行效率高</li>
<li>LinkedList：底层数据结构为<strong>链表结构</strong>，查询，修改比较慢，删除，添加比较快。</li>
<li>Vector：线程安全但效率低</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>特点：无序且不可重复，无序指的是与储存的顺序不一致。</p>
<h5 id="Set的常用子类："><a href="#Set的常用子类：" class="headerlink" title="Set的常用子类："></a>Set的常用子类：</h5><ul>
<li>HashSet：底层数据结构为<strong>哈希表结构</strong>，储存位置不固定。不注重顺序（顺序由系统生成的哈希值决定），只注重唯一性。<ul>
<li>HashSet的比较过程：当向HashSet中存入一个元素时，HashSet会调用该对象的hashCode（）方法来得到该对象的hashCode值，及需要通过equals（）方法比较，返回值都为true时才认为相同。</li>
</ul>
</li>
<li>TreeSet：底层数据结构为二叉树，不仅注重唯一性，还注重顺序。使用时必须使用外部比较器<font color="red">二叉树的特点：每一个根节点大于它左边的所有元素，小于它右面的所有元素。且不论TreeSet或者TreeMap内的对象必须实现Comparable接口，重写compareTo方法否则不能操作</font> 

</li>
</ul>
<h4 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h4><p>Comparable（接口）是默认（内部）的比较器，其中方法为<code>compareTo(Object o)</code><br>ComparaTor是外部自行创建的（自定义）比较器，其中方法为<code>compare(Object o1,Object o2)</code>使用时必须要传入一个新的比较器（ComparaTor）。<br><strong>Comparator的优先级大于Comparable</strong>  </p>
<ul>
<li>ComparaTor接口的使用：<br>  1.创建一个类来实现Comparator接口，实现compare方法<br>  2.使用构造方法传入实现了ComparaTor的对象作为实参<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4></li>
<li>Map&lt;K,V&gt;一个双列集合，key—键值，键值唯一且指向唯一（value），一个键值映射一个值，和Collection属于并列关系。</li>
</ul>
<h5 id="Map的子类："><a href="#Map的子类：" class="headerlink" title="Map的子类："></a>Map的子类：</h5><ul>
<li>Hashtable：底层结构为哈希表结构，不可使用null来充当键和值，同步，效率低，出现于jdk1.0；使用HashSet值作为key的值，key的值只关注唯一性</li>
<li>HashMap：底层结构为哈希表结构，可以使用null来充当键和值，不同步，效率高，出现于jdk1.2；使用TreeSet值作为key的值，key 的值不仅关注唯一性，还关注顺序</li>
<li>TreeMap：底层结构为二叉树，键值必须是自然有序。</li>
</ul>
<h4 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h4><ul>
<li>常用方法：<br>  <code>binarySearch</code>    二分法查找（可指定比较器）<br>  <code>max</code>        返回集合的最大值（可指定比较器）<br>  <code>min</code>        返回集合的最小值（可指定比较器）<br>  <code>reverseOrder</code>    返回一个比较器，强行逆转一个比较器。<br>  <code>sort</code>        排序（可指定比较器）</li>
</ul>
<h4 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h4><ul>
<li>常用方法：<ul>
<li><code>Arrays. binarySearch（）</code>二分法查找</li>
<li><code>Arrays.sort( )</code>升序排序</li>
<li><code>Arrays.toString( )</code>返回指定内容的字符串表示</li>
</ul>
</li>
<li><strong>可变参数：为了简化书写而出现(jdk1.5) 注意：可变参数必须写在最后一个</strong>  </li>
</ul>
<h3 id="泛型（jdk1-5版本后出现）"><a href="#泛型（jdk1-5版本后出现）" class="headerlink" title="泛型（jdk1.5版本后出现）"></a>泛型（jdk1.5版本后出现）</h3><ul>
<li><strong>意义：为了限制集合中储存的类型。泛型可以将运行时的错误提前到了编译阶段，提高了安全性，避免了强制类型转换。</strong>  </li>
<li>向下限定：<code>&lt;? extends E&gt;</code> ?—通配符 </li>
<li>向上限定：<code>&lt;? super E&gt;</code></li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li><p>定义：所有运行中的任务通常对应一个进程，当一个程序进入内存运行时，即变为一个进程。进程是处于运行过程中的程序，并且具有一定的独立性。一个进程至少有一个线程，也可以有多个线程 。</p>
</li>
<li><p><strong>什么时候使用Runnable或Thread？</strong>    </p>
<ul>
<li>取决于这个类需不需要重写run之外的方法。</li>
<li>Runnable不影响本类的继承关系，以及类组成</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>独立性：进程可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。没有经过进程本身允许的情况下，一个用户进程不能直接访问其他进程的地址空间。</li>
<li>动态性：进程和程序的区别在于程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程中加入了时间的概念。进程具有自己的生命周期和状态。</li>
<li>并发性：多个进程可以在单个处理器上并发执行，不会互相影响。  </li>
</ul>
</li>
<li><p>线程的创建：</p>
<ol>
<li>通过继承Thread类来创建并启动线程的步骤：<ul>
<li>定义Thread类的子类，重写该类的<code>run()</code>方法（线程执行体）</li>
<li>创建Thread子类的实例（创建子线程)</li>
<li>调用线程对象的<code>start（）</code>方法来启动线程。</li>
</ul>
</li>
<li>通过实现Runnable接口来创建并启动线程的步骤：<ul>
<li>定义Runnable接口的实现类，重写该接口的<code>run（）</code>方法</li>
<li>创建Runnable实现类的实例</li>
<li>调用线程对象的<code>start（）</code>方法来启动线程</li>
</ul>
</li>
<li>通过创建匿名内部类来创建和启动线程</li>
</ol>
</li>
</ul>
<ul>
<li><p>线程的停止<br><code>interrupt</code> ：唤醒一个被<code>sleep</code>或者被<code>wait</code>的线程（原理是改变循环条件）</p>
</li>
<li><p>线程的五种状态：</p>
<ul>
<li>新建 就绪 运行 阻塞 死亡</li>
<li><font color="red">注意：<br>线程从阻塞状态只能进入就绪状态，不可直接进入运行状态<br>线程进入死亡状态后不可再次调用<code>start（）</code>方法</font>
</li>
</ul>
</li>
<li><p>后台线程（守护线程，精灵线程）：<code>setDaemon（boolean）</code>设置线程为守护线程<br><strong>该方法必须在启动之前调用</strong></p>
<font color="red">如果所有的前台线程都死亡，则后台线程会自动死亡。如垃圾回收线程。</font>


</li>
</ul>
<p>##<strong>多线程</strong></p>
<p><strong>多线程出现安全问题的前提：</strong></p>
<ul>
<li>对于多个线程来说，必须同时操作共享资源</li>
<li>操作资源的代码有多条语句，如果出现挂起，未完整执行语句，由于数据未完成，导致数据发生异常</li>
</ul>
<p>解决办法：<code>synchronized</code>(上锁)<br>每一把锁都是<strong>唯一</strong>的，所以指定一个唯一的对象，虽然允许使用任何对象作为同步监视器（锁），但是锁存在的意义是阻止两个线程对同一个共享资源进行并发访问，所以通常建议<strong>使用可能被并发访问的共享资源充当锁同步监视器（锁）。</strong></p>
<ol>
<li>同步代码块（互斥区）（对象为监视器（锁））<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchrinized（对象）&#123;</span><br><span class="line">		执行代码<span class="number">1</span>；</span><br><span class="line">		执行代码<span class="number">2</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<font color="red"><strong>只要操作了共享数据就应该使用同步代码块</strong></font>

<ol start="2">
<li>同步方法（方法）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> test&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<font color="red">同步方法的锁对象就是当前类的对象（this）</font>

<ol start="3">
<li>同步静态方法<br><code>public static synchronized void test{  }</code><font color="red">同步方法的同步监视器是<code>this</code> 即调用该方法的对象 。<br>静态同步方法的同步监视器（锁对象）是当前类.class</font>
</li>
</ol>
<ul>
<li><strong>wait和sleep的区别</strong><ol>
<li>wait会放弃执行资格，会释放锁。不占用cpu</li>
<li>sleep放弃执行资格，但是不会释放锁，sleep后进入了阻塞状态，占用cpu</li>
</ol>
</li>
</ul>
<h3 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h3><ul>
<li><code>wait()</code>—让线程冻结</li>
<li><code>notify()</code>—唤醒第一个冻结线程</li>
<li><code>notifyAll()</code>—唤醒所有冻结线程</li>
<li><strong>使用前提是有锁，因为与锁有关，且锁可以是任意对象，所以将这三个方法定义在Object中。</strong></li>
<li><font color="red"><br>线程间通信时产生的线程安全问题解决办法：<br>  1. 只要是操作了共享的数据，都需要使用同步代码块，且同步代码块的锁必须统一</font><br>   <font color="red"><br>  2. 先判断是否继续循环，使用while来控制线程被唤醒后，必须判断是否执行，notifyAll全部唤醒线程，防止进程唤醒本类线程，导致安全问题。</font>



</li>
</ul>
<h3 id="生产者、消费者模式"><a href="#生产者、消费者模式" class="headerlink" title="生产者、消费者模式"></a>生产者、消费者模式</h3><p>jdk1.5之前使用<code>while notifyAll</code>方法，之后使用<code>lock Condition</code>方法实现，相比较，<code></code>方式更加灵活，可以指定需要启动的线程。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>死锁出现的必要条件：<ol>
<li>资源匮乏</li>
<li>有多个锁，多个线程都操作了此资源</li>
<li>锁之间有使用对方资源的情况，必须有两把锁以上，且需锁中有锁。</li>
</ol>
</li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul>
<li>分类<ul>
<li>根据流的操作数据的方式来分为字节流和字符流</li>
<li>根据流向可分为输入流和输出流</li>
</ul>
</li>
</ul>
<ul>
<li>字节流和字符流：<ul>
<li><code>OutputStream/ InputStream</code>是所有字节输出/输入流的父类</li>
<li><code>Writer/Reader</code>是所有字符输出/输入流的父类</li>
</ul>
</li>
</ul>
<blockquote>
<font color="red">流必须关闭！关闭后不可再次写入，不能重复关闭！输入和输出流不是同一个流！<br>关闭流后不可再次刷新流缓冲或者写入流读取流</font>
</blockquote>
<ul>
<li>字节流 <code>Writer/Reader</code></li>
<li>IO的异常处理<br>一般在<code>finally（）</code>方法中调用<code>close（）</code>方法，需注意：流必须在try外部定义，因为需要关流</li>
<li>字符流的缓冲区（前缀带Buffered）<br>Buffered不能单独使用，需要传入一个流</li>
</ul>
<h3 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h3><ul>
<li><p>目的是为了增强某些类的功能，创建一个新类，然后一般在构造方法中将被装饰者作为参数，这个自定义类就是装饰类，这两个类的功能是相似的，但是会对功能做一个增强，装饰类和被装饰类也是一个体系中的类。</p>
</li>
<li><p>装饰和继承的关系<br>相对于继承来说，降低了类之间的耦合性，且装饰类和被装饰类属于同一体系。</p>
</li>
<li><p>字节流<br>OutputStream/InputStream<br><strong>写入时需注意只能写入Byte类型的值，所以需要String的<code>getBytes()</code>方法</strong></p>
</li>
<li>读取的方法：<ul>
<li>一个字节一个字节的读取</li>
<li>读入一个数组</li>
<li>将内容一次性读出</li>
</ul>
</li>
</ul>
<ul>
<li>键盘录入：<br>InputStream i=System.in;</li>
</ul>
<ul>
<li><p><strong>转换流</strong><br>InputStreamReader/OutoutStreamReader<br><code>InputStreamReader isr=new InputStremReader(new FileInputStream(“目录”))</code></p>
</li>
<li><p>如何选择流：</p>
<ol>
<li>确定源和目的，源是数据的来源，目的是数据走到哪</li>
<li>确定操作对象是否为纯文本文件</li>
</ol>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><ul>
<li>三要素：ip、端口、协议</li>
<li>OSI网络层次参考模型/TCP&amp;IP参考模型</li>
<li><strong>TCP和UDP的区别</strong><ol>
<li>基于连接和无连接</li>
<li>TCP要求系统资源较多，UPD较少</li>
<li>UDP程序结构较简单</li>
<li>流模式（TCP）和数据包模式（UDP）</li>
<li>TCP保证数据正确性和数据的顺序，UDP不保证</li>
<li>其他请<a href="http://blog.csdn.net/li_ning_/article/details/52117463" target="_blank" rel="noopener">参考</a></li>
</ol>
</li>
</ul>
<p>###socket—-插座  套接字</p>
<ul>
<li>socket就是为了网络服务提供的一种机制<br>通信的两端都是socket<br>socket位于传输层和会话层之间<br>网络的通信其实都是socket间的通信<br>数据在两个socket间进行IO传输<br>java中对应Socket类</li>
</ul>
<ul>
<li><strong>java实现TCP和UDP连接的步骤</strong></li>
</ul>
<ul>
<li><p>TCP：</p>
<ol>
<li>创建客户端和服务端</li>
<li>服务端：建立服务端的SeverSocket，监听端口；获取连接的客户端对象（使用accept方法，此方法为阻塞式方法，会一直持续监听）；定义socket对象的输入输出流；使用输出流发送给客户端信息，使用输入流获取客户端发送的信息。</li>
</ol>
<ul>
<li>客户端：建立客户端的Socket，指定连接的服务端地址和端口；定义socket对象的输入输出流；使用输出流（字节流）向服务端发送信息，使用输入流（字节流）获取服务器的回执。</li>
</ul>
</li>
<li><p>UDP：</p>
<ol>
<li>创建接收端和发送端</li>
<li>发送端：建立DatagremScoket对象，指定本方端口及ip；使用转换流获取输入要发送的内容，并且转换为字节；将内容打包，然后发送；</li>
</ol>
<ul>
<li>接受端：建立DatagremScoket对象，监听端口，将接受到的数据包拆包（使用receive方法，此方法为阻塞式方法，）为字节数组。</li>
</ul>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/09/17/DispatchServlet/"></a><a class="next" href="/2018/09/17/Hibernate/"></a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Trtmu.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>